// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: client_batch_submit.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2017 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// -----------------------------------------------------------------------------

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Information about the status of a batch submitted to the validator.
///
/// Attributes:
///     batch_id: The id (header_signature) of the batch
///     status: The committed status of the batch
///     invalid_transactions: Info for transactions that failed, if any
///
/// Statuses:
///     COMMITTED - the batch was accepted and has been committed to the chain
///     INVALID - the batch failed validation, it should be resubmitted
///     PENDING - the batch is still being processed
///     UNKNOWN - no status for the batch could be found (possibly invalid)
public struct ClientBatchStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batchID: String = String()

  public var status: ClientBatchStatus.Status = .unset

  public var invalidTransactions: [ClientBatchStatus.InvalidTransaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unset // = 0
    case committed // = 1
    case invalid // = 2
    case pending // = 3
    case unknown // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unset
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unset
      case 1: self = .committed
      case 2: self = .invalid
      case 3: self = .pending
      case 4: self = .unknown
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unset: return 0
      case .committed: return 1
      case .invalid: return 2
      case .pending: return 3
      case .unknown: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct InvalidTransaction {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var transactionID: String = String()

    public var message: String = String()

    public var extendedData: Data = SwiftProtobuf.Internal.emptyData

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension ClientBatchStatus.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ClientBatchStatus.Status] = [
    .unset,
    .committed,
    .invalid,
    .pending,
    .unknown,
  ]
}

#endif  // swift(>=4.2)

/// Submits a list of Batches to be added to the blockchain.
public struct ClientBatchSubmitRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batches: [Batch] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This is a response to a submission of one or more Batches.
/// Statuses:
///   * OK - everything with the request worked as expected
///   * INTERNAL_ERROR - general error, such as protobuf failing to deserialize
///   * INVALID_BATCH - the batch failed validation, likely due to a bad signature
///   * QUEUE_FULL - the batch is unable to be queued for processing, due to
///        a full processing queue.  The batch may be submitted again.
public struct ClientBatchSubmitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: ClientBatchSubmitResponse.Status = .unset

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unset // = 0
    case ok // = 1
    case internalError // = 2
    case invalidBatch // = 3
    case queueFull // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unset
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unset
      case 1: self = .ok
      case 2: self = .internalError
      case 3: self = .invalidBatch
      case 4: self = .queueFull
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unset: return 0
      case .ok: return 1
      case .internalError: return 2
      case .invalidBatch: return 3
      case .queueFull: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension ClientBatchSubmitResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ClientBatchSubmitResponse.Status] = [
    .unset,
    .ok,
    .internalError,
    .invalidBatch,
    .queueFull,
  ]
}

#endif  // swift(>=4.2)

/// A request for the status of one or more batches, specified by id.
/// If `wait` is set to true, the validator will wait to respond until all
/// batches are committed, or until the specified `timeout` in seconds has
/// elapsed. Defaults to 300.
public struct ClientBatchStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batchIds: [String] = []

  public var wait: Bool = false

  public var timeout: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This is a response to a request for the status of specific batches.
/// Statuses:
///   * OK - everything with the request worked as expected
///   * INTERNAL_ERROR - general error, such as protobuf failing to deserialize
///   * NO_RESOURCE - the response contains no data, likely because
///     no ids were specified in the request
public struct ClientBatchStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: ClientBatchStatusResponse.Status = .unset

  public var batchStatuses: [ClientBatchStatus] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unset // = 0
    case ok // = 1
    case internalError // = 2
    case noResource // = 5
    case invalidID // = 8
    case UNRECOGNIZED(Int)

    public init() {
      self = .unset
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unset
      case 1: self = .ok
      case 2: self = .internalError
      case 5: self = .noResource
      case 8: self = .invalidID
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unset: return 0
      case .ok: return 1
      case .internalError: return 2
      case .noResource: return 5
      case .invalidID: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension ClientBatchStatusResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ClientBatchStatusResponse.Status] = [
    .unset,
    .ok,
    .internalError,
    .noResource,
    .invalidID,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ClientBatchStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ClientBatchStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_id"),
    2: .same(proto: "status"),
    3: .standard(proto: "invalid_transactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.batchID)
      case 2: try decoder.decodeSingularEnumField(value: &self.status)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.invalidTransactions)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.batchID.isEmpty {
      try visitor.visitSingularStringField(value: self.batchID, fieldNumber: 1)
    }
    if self.status != .unset {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.invalidTransactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invalidTransactions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ClientBatchStatus, rhs: ClientBatchStatus) -> Bool {
    if lhs.batchID != rhs.batchID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.invalidTransactions != rhs.invalidTransactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientBatchStatus.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSET"),
    1: .same(proto: "COMMITTED"),
    2: .same(proto: "INVALID"),
    3: .same(proto: "PENDING"),
    4: .same(proto: "UNKNOWN"),
  ]
}

extension ClientBatchStatus.InvalidTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ClientBatchStatus.protoMessageName + ".InvalidTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
    2: .same(proto: "message"),
    3: .standard(proto: "extended_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.transactionID)
      case 2: try decoder.decodeSingularStringField(value: &self.message)
      case 3: try decoder.decodeSingularBytesField(value: &self.extendedData)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.extendedData.isEmpty {
      try visitor.visitSingularBytesField(value: self.extendedData, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ClientBatchStatus.InvalidTransaction, rhs: ClientBatchStatus.InvalidTransaction) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.message != rhs.message {return false}
    if lhs.extendedData != rhs.extendedData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientBatchSubmitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ClientBatchSubmitRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batches"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.batches)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.batches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.batches, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ClientBatchSubmitRequest, rhs: ClientBatchSubmitRequest) -> Bool {
    if lhs.batches != rhs.batches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientBatchSubmitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ClientBatchSubmitResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unset {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ClientBatchSubmitResponse, rhs: ClientBatchSubmitResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientBatchSubmitResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSET"),
    1: .same(proto: "OK"),
    2: .same(proto: "INTERNAL_ERROR"),
    3: .same(proto: "INVALID_BATCH"),
    4: .same(proto: "QUEUE_FULL"),
  ]
}

extension ClientBatchStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ClientBatchStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_ids"),
    2: .same(proto: "wait"),
    3: .same(proto: "timeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.batchIds)
      case 2: try decoder.decodeSingularBoolField(value: &self.wait)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.timeout)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.batchIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.batchIds, fieldNumber: 1)
    }
    if self.wait != false {
      try visitor.visitSingularBoolField(value: self.wait, fieldNumber: 2)
    }
    if self.timeout != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeout, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ClientBatchStatusRequest, rhs: ClientBatchStatusRequest) -> Bool {
    if lhs.batchIds != rhs.batchIds {return false}
    if lhs.wait != rhs.wait {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientBatchStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ClientBatchStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "batch_statuses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.batchStatuses)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unset {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.batchStatuses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.batchStatuses, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ClientBatchStatusResponse, rhs: ClientBatchStatusResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.batchStatuses != rhs.batchStatuses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientBatchStatusResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSET"),
    1: .same(proto: "OK"),
    2: .same(proto: "INTERNAL_ERROR"),
    5: .same(proto: "NO_RESOURCE"),
    8: .same(proto: "INVALID_ID"),
  ]
}
